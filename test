;; normalize an identity function for nat x nat x nat
;; (lam (x x))
;; (Pi
;;  (Sig Nat (_ (Sig Nat (_ Nat))))
;;  (_ (Sig Nat (_ (Sig Nat (_ Nat))))))
;;
;; expected result:
;;    (lam (x (pair (fst (fst x)) (pair (fst (snd x)) (snd (snd x))))))

;; normalize an identity function for (nat -> nat) -> nat
;; (lam (x x))
;; (Pi
;;  (Pi (Pi Nat (_ Nat)) (_ Nat))
;;  (_
;;   (Pi (Pi Nat (_ Nat)) (_ Nat))))

;; expected result:
;;    (lam (x1 (lam (x2 (ap x1 (lam (x3 (ap x2 x3))))))))

;; Compute the 25th fibonacci number.
;; (let
;;     ((plus
;;       (check
;;        (lam Nat (a (lam Nat (b (nrec (_ Nat) a (a b (suc b)) b)))))
;;        (Pi Nat (_ (Pi Nat (_ Nat))))))
;;      (fib
;;       (check
;;        (lam Nat
;;             (n (nrec
;;                 (_ (Sig Nat (_ Nat)))
;;                 (pair 1 0)
;;                 (_ p (pair (ap plus (fst p) (snd p)) (fst p)))
;;                 n)))
;;        (Pi Nat (_ (Sig Nat (_ Nat)))))))
;;   (snd (ap fib 25)))
;; Nat
;;
;; expected result:
;;    75025

;; Test computing with universes
;; (ap
;;  (check (lam (U 3) (x (Pi x (_ (U 0))))) (Pi (U 3) (_ (U 3))))
;;  (U 2))
;; (U 3)
;;
;; expected result:
;;    Pi (U 2) (_ (U 0))

;; (shut (open (check (shut 1) (Box Nat))))
;; (Box Nat)
;;
;; expected result:
;;   (shut 1)

;; (shut
;;  (prev
;;   (dfix
;;    (prev
;;     (dfix
;;      (U 0)
;;      (x
;;       (Sig Nat (_ (Later (y (prev x y)))))))
;;     <>)
;;    (x
;;     (pair 0 (next (t (prev x t))))))
;;   <>))
;; (Box
;;  (prev
;;   (dfix
;;    (U 0)
;;    (x
;;     (Sig Nat (_ (Later (y (prev x y)))))))
;;   <>))

;; (lam (A (lam (x (open x)))))
;; (Pi (U 0) (A (Pi (Box A) (_ A))))

;; Should fail:
;; (lam (Later (_ Nat)) (x (prev x <>)))
;; (Pi (Later (_ Nat)) (_ Nat))

;; Should also fail
;; (lam (Later (_ (Later (_ Nat)))) (x (next (y (prev (prev x y) y)))))
;; (Pi (Later (_ (Later (_ Nat)))) (_ (Later (_ Nat))))

(let
    ((fix
      (check
       (lam
        (U 0)
        (A
         (lam
          (Pi (Later (_ A)) (_ A))
          (f (ap f (dfix A (x (ap f x))))))))
       (Pi (U 0) (A (Pi (Pi (Later (_ A)) (_ A)) (_ A))))))
     (fix1
      (check
       (lam
        (U 1)
        (A
         (lam
          (Pi (Later (_ A)) (_ A))
          (f (ap f (dfix A (x (ap f x))))))))
       (Pi (U 1) (A (Pi (Pi (Later (_ A)) (_ A)) (_ A))))))
     (StreamF
      (check
       (lam
        (U 0)
        (A
         (lam
          (Later (_ (U 0)))
          (S (Sig A (_ (Later (t (prev S t)))))))))
       (Pi (U 0) (_ (Pi (Later (_ (U 0))) (_ (U 0)))))))
     (Stream
      (check
       (lam
        (U 0)
        (A (ap fix1 (U 0) (ap StreamF A))))
       (Pi (U 0) (_ (U 0)))))
     (StreamTick
      (check
       (lam
        (U 0)
        (A (Later (t (prev (dfix (U 0) (x (ap StreamF A x))) t)))))
       (Pi (U 0) (_ (U 0)))))
     (into
      (check
       (lam
        (U 0)
        (A
         (lam
          (Later (_ (ap Stream A)))
          (x
           (next
            (t
             (let ((str (prev x t)))
               ?)))))))
       (Pi
        (U 0)
        (A (Pi (Later (_ (ap Stream A))) (_ (ap StreamTick A))))))))
  zero)
Nat
