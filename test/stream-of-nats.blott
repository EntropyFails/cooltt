let fix : (A : U<0>) -> ((Later -> A) -> A) -> A =
  fun A -> fun f -> f (dfix (x : Later -> A) -> f x)

let fix1 : (A : U<1>) -> ((Later -> A) -> A) -> A =
  fun A -> fun f -> f (dfix (x : Later -> A) -> f x)

let StreamF : (Later -> (Nat -> U<0>)) -> (Nat -> U<0>) =
  fun tail -> fun _ -> Nat * (Later t -> tail[t] 0)

let Stream : Nat -> U<0> = fix1 (Nat -> U<0>) StreamF

let UnfoldedStream : Nat -> U<0> =
  fun n -> Later t -> (dfix (x : Later -> Nat -> U<0>) -> StreamF x)[t] n

let into : (Later -> Stream 0) -> UnfoldedStream 0 =
  fun s -> next t -> fold[0][0 : Nat][x -> StreamF x] (s[t]) t

let out : (UnfoldedStream 0) -> (Later -> Stream 0) =
  fun s -> next t -> unfold[0][0 : Nat][x -> StreamF x] (s[t]) t

let cons : Nat -> (Later -> Stream 0) -> Stream 0 =
  fun x -> fun s -> <x, into s>

let head : (Stream 0) -> Nat =
  fun s -> fst s

let tail : (Box (Stream 0)) -> Box (Stream 0) =
  fun x -> shut ((snd (open x))[<>])

let n-tail : Nat -> (Box (Stream 0)) -> (Box (Stream 0)) =
  fun n ->
  rec n at x -> (Box (Stream 0)) -> (Box (Stream 0)) with
  | zero -> fun s -> s
  | suc _, f -> fun s -> f (tail s)

let nth : Nat -> (Box (Stream 0)) -> Nat =
  fun x -> fun s -> head (open (n-tail x s))

let count-up-from : Nat -> Stream 0 =
  fix (Nat -> Stream 0)
  (fun tail ->
     fun n -> cons n (next t -> tail[t] (suc n)))

normalize nth 100 (shut (count-up-from 0)) at Nat
