;; normalize an identity function for nat x nat x nat
;; (lam (x x))
;; (Pi
;;  (Sig Nat (_ (Sig Nat (_ Nat))))
;;  (_ (Sig Nat (_ (Sig Nat (_ Nat))))))
;;
;; expected result:
;;    (lam (x (pair (fst (fst x)) (pair (fst (snd x)) (snd (snd x))))))

;; normalize an identity function for (nat -> nat) -> nat
;; (lam (x x))
;; (Pi
;;  (Pi (Pi Nat (_ Nat)) (_ Nat))
;;  (_
;;   (Pi (Pi Nat (_ Nat)) (_ Nat))))

;; expected result:
;;    (lam (x1 (lam (x2 (ap x1 (lam (x3 (ap x2 x3))))))))

;; Compute the 25th fibonacci number.
;; (let
;;     ((plus
;;       (check
;;        (lam Nat (a (lam Nat (b (nrec (_ Nat) a (a b (suc b)) b)))))
;;        (Pi Nat (_ (Pi Nat (_ Nat))))))
;;      (fib
;;       (check
;;        (lam Nat
;;             (n (nrec
;;                 (_ (Sig Nat (_ Nat)))
;;                 (pair 1 0)
;;                 (_ p (pair (ap plus (fst p) (snd p)) (fst p)))
;;                 n)))
;;        (Pi Nat (_ (Sig Nat (_ Nat)))))))
;;   (snd (ap fib 25)))
;; Nat
;;
;; expected result:
;;    75025

;; Test computing with universes
;; (ap
;;  (check (lam (U 3) (x (Pi x (_ (U 0))))) (Pi (U 3) (_ (U 3))))
;;  (U 2))
;; (U 3)
;;
;; expected result:
;;    Pi (U 2) (_ (U 0))

;; (shut (open (check (shut 1) (Box Nat))))
;; (Box Nat)
;;
;; expected result:
;;   (shut 1)

;; (shut
;;  (prev
;;   (dfix
;;    (prev
;;     (dfix
;;      (U 0)
;;      (x
;;       (Sig Nat (_ (Later (y (prev x y)))))))
;;     <>)
;;    (x
;;     (pair 0 (next (t (prev x t))))))
;;   <>))
;; (Box
;;  (prev
;;   (dfix
;;    (U 0)
;;    (x
;;     (Sig Nat (_ (Later (y (prev x y)))))))
;;   <>))

;; (lam (A (lam (x (open x)))))
;; (Pi (U 0) (A (Pi (Box A) (_ A))))

;; Should fail:
;; (lam (Later (_ Nat)) (x (prev x <>)))
;; (Pi (Later (_ Nat)) (_ Nat))

;; Should also fail
(lam (Later (_ (Later (_ Nat)))) (x (next (y (prev (prev x y) y)))))
(Pi (Later (_ (Later (_ Nat)))) (_ (Later (_ Nat))))
